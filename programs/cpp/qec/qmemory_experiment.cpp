// Copyright 2023 Alibaba Group

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at

//     http://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/* Simulate part of a quantum memory experiment on a logical qubit. This
experiment assumes a qubit topology tailor-made for QEC. You can switch to that
topology by running `make qec`; see README.md for more details.

Currently, this program is only intended for estimating the instruction issuing
throughput for the bulk of the syndrome extraction circuit. As such, it is
missing the initialization and the final measurement. It is intended to be run
with the `stim` backend, which currently does not implement any error model, so
the results should be what would be observed with perfect syndrome extraction.

Specifically, this program simulates 5 rounds of syndrome extraction, and for
each round the program outputs the following:
* The magic number "100" (making it easier to visually parse the output).
* The round number.
* The magic number "200".
* A sequence of X syndromes.
* A sequence of Z syndromes.

The number of X syndromes and Z syndromes should be equal; for the default
QEC_SIZE=3, there should be 4 syndromes each. Furthermore, with perfect syndrome
extraction, the X syndromes should alternate between a random bit string (fixed
for a single run) and the all-zeros string each round, and the Z syndromes
should alternate between all-ones and all-zeros. (This pattern arises because we
do not reset the ancilla qubits each round, and also due to the single-qubit
gate used.)
*/
#include <cmath>

#include "../yqe.h"

// This file contains some constants that depend on the QEC qubit topology.
// It is generated by `make qec`, and changes with the QEC_SIZE parameter.
#include "../../qec.h"

const int DELAY_1Q = 20, DELAY_2Q = 40, DELAY_MEAS = 600;
const int num_rounds = 5;

extern "C" {
void memset(volatile void *dest, int val, size_t n);
void memcpy(volatile void *dest, volatile void *src, size_t n);
}

void apply_operations(int channel_start, int waveform, int len, int delay) {
  memset(ADDR_PLAY + channel_start, waveform, len);
  if (delay) *ADDR_WAIT = delay;
}

void apply_1q_gates(int start, int end, int delay) {
  // The single-qubit gate used to switch between the X basis and the Z basis
  // is a R_y(\pi/2) rotation gate (which is easier to implement on the hardware
  // than an H gate). For maximum ease of implementation, we only rotate in one
  // direction, which is equivalent to introducing some extra Pauli Y gates in
  // the circuit (which can be easily eliminated through classical
  // postprocessing).
  apply_operations(CHANNEL_1Q(start), WAVEFORM_PI_2, end - start, delay);
}

void apply_2q_gates(int start, int end, int delay) {
  apply_operations(CHANNEL_2Q(start), WAVEFORM_CZ, end - start, delay);
}

void apply_measurements(int start, int end, int delay) {
  apply_operations(CHANNEL_1Q(start), WAVEFORM_MEAS, end - start, delay);
}

int main() {
  int result[N_QUBITS - N_DATA_QUBITS];
  *ADDR_TRIGGER_BITMASK = BITMASK;
  *ADDR_TRIGGER_INTERVAL = 0;  // trigger repeat is disabled
  for (int i = 0; i < N_QUBITS; i++) ADDR_PARAMS[CHANNEL_1Q(i)][0] = M_PI_2;
  for (int round = 0; round < num_rounds; round++) {
    *ADDR_OFFSET = round * N_QUBITS * sizeof(int);
    // Apply 1Q gates to data qubits and X ancilla qubits.
    apply_1q_gates(D1_START, X2_END, DELAY_1Q);
    // Apply 4 groups of CZ gates to measure X stabilizers.
    apply_2q_gates(SLOT_0_START, SLOT_0_END, DELAY_2Q);
    apply_2q_gates(SLOT_1_START, SLOT_1_END, DELAY_2Q);
    apply_2q_gates(SLOT_2_START, SLOT_2_END, DELAY_2Q);
    apply_2q_gates(SLOT_3_START, SLOT_3_END, DELAY_2Q);
    // Apply 1Q gates to data qubits, X ancilla qubits, and Z ancilla qubits.
    apply_1q_gates(D1_START, Z2_END, DELAY_1Q);
    // Measure the X ancilla qubits.
    apply_measurements(X1_START, X2_END, 0);
    // Apply 4 groups of CZ gates to measure Z stabilizers.
    apply_2q_gates(SLOT_4_START, SLOT_4_END, DELAY_2Q);
    apply_2q_gates(SLOT_5_START, SLOT_5_END, DELAY_2Q);
    apply_2q_gates(SLOT_6_START, SLOT_6_END, DELAY_2Q);
    apply_2q_gates(SLOT_7_START, SLOT_7_END, DELAY_2Q);
    // Apply 1Q gates to Z ancilla qubitsi only.
    apply_1q_gates(Z1_START, Z2_END, DELAY_1Q);
    // Measure the Z ancilla qubits.
    apply_measurements(Z1_START, Z2_END, DELAY_MEAS - DELAY_2Q * 4 - DELAY_1Q);
  }
  trigger(1);
  for (int round = 0; round < num_rounds; round++) {
    memcpy(result, ADDR_FMR + round * N_QUBITS + N_DATA_QUBITS, sizeof(result));
    // The below output procedure is just for testing
    // In realistic scenarios, syndromes should be fed to a decoder
    *ADDR_PCIE = 100;
    *ADDR_PCIE = round;
    *ADDR_PCIE = 200;
    for (int i = 0; i < N_QUBITS - N_DATA_QUBITS; i++) *ADDR_PCIE = result[i];
  }
  return 0;
}
